# xline_path_planner 使用指南（对外文档）

本包提供“从 CAD JSON 到规划结果 JSON”的完整流水线，支持两种调用方式（聚焦 ROS 生态）：
- ROS 2 节点 `planner_node`（自动从包内 YAML 加载配置）
- C++ 规划引擎库（以字符串为 I/O，便于在自定义 ROS 服务/Action 中复用）

本指南覆盖构建、配置、输入输出规范、两种调用方式与常见问题。

## 1. 构建与安装

- 环境前置：ROS 2 Humble（已提供 `rclcpp`）、OpenCV、yaml-cpp。
- 构建：
  - `source /opt/ros/humble/setup.bash`
  - `colcon build --packages-select xline_path_planner --cmake-args -DCMAKE_BUILD_TYPE=Release`
  - `source install/setup.bash`

构建完成后，以下可执行与资源被安装：
- 可执行：`planner_node`
- 配置：`share/xline_path_planner/config/planner.yaml`

## 2. 配置（严格模式，无默认值）

配置文件：`xline_path_planner/config/planner.yaml`（安装后位于 `share/xline_path_planner/config`）。
所有键均为必填，缺失将直接报错终止（无代码默认值回退）。

分组与字段：
- visualization
  - `scale`、`show_grid_lines`、`use_antialiasing`、`image_format`、`save_path_visualization`、`output_dir`
- cad_parser
  - `unit_conversion_factor`、`auto_scale_coordinates`、`angle_unit`（DEGREES/RADIANS）
- grid_map
  - `resolution`、`padding`
- offsets
  - `left_offset`、`right_offset`、`printer_type`（LEFT_PRINTER/RIGHT_PRINTER/BOTH_PRINTERS）
- path_planner
  - `transition_speed`、`drawing_speed`、`path_extension_length`
- trajectory
  - `max_velocity`、`max_acceleration`

示例：`xline_path_planner/config/planner.yaml`

## 3. 输入 CAD JSON 规范（简版）

- 根键 `lines`（array）必需；可选 `layers`（用于 layer_id→name 映射）。
- `lines[*]`：`type` 为 `line`/`circle`/`arc`，并按类型提供：
  - line：`start{x,y[,z]}`，`end{x,y[,z]}`
  - circle：`center{x,y[,z]}`，`radius`
  - arc：`center{x,y[,z]}`，`radius`，`start_angle`，`end_angle`（度或弧度由配置确定/自动判断）
- 可选：`id`、`layer_id` 或 `layer`、`line_type`、`thickness`、`hidden`、`color`、`selected`。
- 图层名包含“路径/path/axis/draw/drawing”→ 路径；“障碍/barrier/obstacle”→ 障碍；“空洞/hole/hollow/void/opening”→ 空洞；否则默认归入路径。

参考：`xline_path_planner/include/xline_path_planner/cad_parser.hpp:22`

## 4. 输出 JSON 规范（简版）

- 仅返回 `{ "lines": [...] }`。
- 路径段按规划顺序展开：
  - 绘图段：`type` 可能为 `line`/`polyline`/`circle`/`arc`，均包含：`id`、`order`、`work:true`、`start`、`end`，以及源几何的可选元数据（`line_type`、`thickness`、`hidden`、`layer(_id)`、`color`、`selected`）。
  - 转场段：拆为若干 `line`，附 `work:false`，`layer` 标记为 `TRANSITION`。
- 距离单位：导出为毫米（input 若为米，将转换为毫米）。

生成逻辑参考：`xline_path_planner/src/output_formatter.cpp`

## 5. 调用方式一：ROS 2 节点（Service）

- 运行节点：
  - `ros2 run xline_path_planner planner_node`
- 行为：
  - 启动即从包安装目录的 `config/planner.yaml` 严格加载配置（通过 `ament_index_cpp` 定位）。
  - 提供 Service：`/plan_path`，接口为 `xline_path_planner/srv/PlanPath`。
  - 客户端通过请求传入 `file_name`（仅文件名，不含路径）。服务端在配置 `cad_parser.cad_file_dir` 下拼接成完整路径进行处理，响应包含 `success`、`error` 与 `message`。
  - 图像输出：当 `visualization.save_path_visualization` 为 true，将把栅格图与路径可视化图保存到 `visualization.output_dir` 目录：
    - 栅格图：`grid_map.<image_format>`
    - 路径图：`planned_paths.<image_format>`
  - 规划结果 JSON 输出：始终保存到 `visualization.planned_output_dir` 目录，文件名为 `planned_<文件名stem>.json`
  - 不再从配置文件的 files 组读取输入/输出路径；输入通过 Service 传递文件名。

接口概要：
- Request：`string file_name`
- Response：`bool success`，`string error`，`string message`

代码参考：`xline_path_planner/src/main.cpp`

## 6. 调用方式二：TCP 服务

- 端口与开关：在 `config/planner.yaml` 中配置 `tcp_server`，默认开启，监听 `0.0.0.0:52088`。
- 协议：
  - 客户端建立 TCP 连接后，发送一行文本，内容为 CAD 文件名（不含路径），以 `\n` 结尾。
  - 服务端读取后，与 `cad_parser.cad_file_dir` 拼接为完整路径并执行规划。
  - 返回一行 JSON 文本：`{"success":true|false, "error":"...", "message":"..."}`，随后断开连接。
- 示例（netcat）：
  - 发送：`printf "cad_2_transformed.json\n" | nc 127.0.0.1 52088`
  - 响应：`{"success": true, "error": "", "message": "规划完成，结果已保存至目录: ..."}`

更多细节与示例代码见：docs/tcp_api.md

## 7. 调用方式三：C++ 库（嵌入式于 ROS 服务/Action）

- 头文件：`xline_path_planner/include/xline_path_planner/planner_engine.hpp`
- 典型用法：

```cpp
#include <yaml-cpp/yaml.h>
#include <fstream>
#include <sstream>
#include "xline_path_planner/planner_engine.hpp" // 仅用于 PlannerEngineConfig 定义
#include "xline_path_planner/cad_parser.hpp"
#include "xline_path_planner/grid_map_generator.hpp"
#include "xline_path_planner/path_planner.hpp"
#include "xline_path_planner/output_formatter.hpp"

using namespace daosnrs_planning;

PlannerEngineConfig load_cfg(const std::string& yaml_path) {
  YAML::Node root = YAML::LoadFile(yaml_path);
  PlannerEngineConfig cfg;
  // 严格读取各分组，示例略（可参考 src/main.cpp 中的加载逻辑）
  // cfg.cad_parser / cfg.grid_map / cfg.offsets / cfg.path_planner / cfg.trajectory
  return cfg;
}

std::string run(const std::string& cad_json, const PlannerEngineConfig& cfg) {
  using namespace daosnrs_planning;
  // 1) 解析 CAD
  CADParser parser(cfg.cad_parser);
  if (!parser.parse_from_string(cad_json)) throw std::runtime_error("CAD JSON 解析失败");
  CADData cad = parser.get_cad_data();
  // 2) 栅格
  GridMapGenerator g(cfg.grid_map);
  if (!g.generate_from_cad(cad)) throw std::runtime_error("栅格地图生成失败");
  // 3) 路径
  PathPlanner planner(cfg.path_planner);
  planner.set_grid_map(g.get_grid_map(), &g);
  auto segs = planner.plan_paths(cad, cfg.offsets);
  if (segs.empty()) throw std::runtime_error("路径规划失败");
  // 4) 输出
  OutputFormatter fmt;
  return fmt.format_planned_paths_to_cad_json(segs, cad, "in_memory.json").dump(2);
}
```

流程参考：`xline_path_planner/src/main.cpp` 中的 `execute` 实现

提示：如需通过 ROS 2 Service/Action 接口“收 JSON、回 JSON”，可直接在服务端重用上述 1)~4) 流程（解析→栅格→规划→格式化），与节点一致。

## 7. 常见问题（FAQ）

- 运行找不到配置或提示“配置缺失: xxx”
  - 检查 YAML 是否完整，所有必填键是否存在；节点模式下需先 `colcon build && source install/setup.bash`
- `planner_node` 启动报“无法获取包共享目录”
  - 未 source 安装环境或包未安装；执行 `colcon build` 并 `source install/setup.bash`
- 输出 JSON 的单位是什么？
  - 输出按毫米导出；内部计算在配置控制下进行单位换算
- 能否在每次请求时携带独立配置？
  - 当前 Action 已移除 `config_yaml` 字段，暂不支持按请求覆盖配置。
  - 如需动态配置，建议：
    - 使用 ROS 参数或参数服务在节点层更新配置；或
    - 自行封装一个服务/Action 接口，用于下发配置并重建内部引擎；或
    - 运行多个节点实例，分别加载不同配置文件。

## 8. 性能与建议

- CAD JSON 体量较大时，适当增大 `grid_map.resolution`（更粗栅格）可显著提速
- 合理设置 `path_planner.path_extension_length`、`offsets.*`，可减少路径碎片化
- 可视化仅用于调试，生产环境可关闭以减少 I/O

## 9. 版本与可复现性

- 建议在产出 JSON 的 metadata 中记录：配置文件快照（或哈希）、源文件名、时间戳与包版本
- Action Result 中的 `planner_version` 字段当前固定为 `xline_path_planner-0.0.0`；如需更精细的版本与配置哈希，可在上层封装中加入或扩展节点逻辑。

---

如需扩展到服务形态（HTTP/gRPC/ROS 2 Action）、加入进度与取消，请参考 `main.cpp` 内 `execute` 流程自行封装。
